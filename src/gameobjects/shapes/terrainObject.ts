import * as THREE from "three";
import * as CANNON from 'cannon-es'
import { Utility } from "../../utility";
import { TextureToArray } from "./textureToArray";


// TODO: combine PlaneObject and GroundObject (in progress)
export class TerrainObject {
    
    body?: CANNON.Body;
    heightfieldShape!: CANNON.Heightfield;
    physicsMaterial?: CANNON.Material;

    generatedMesh: THREE.Mesh;
    grid?: THREE.GridHelper;

    displacementMesh?: THREE.Mesh;

    constructor(scene: THREE.Scene,
        meshMaterial: THREE.Material,
        world: CANNON.World,
        physicsMaterial: CANNON.Material,
        heightMapTextureAsArray: TextureToArray,
        displacementHeightFactor: number,
        isCannonMeshVisible: boolean,
        isTexturedMeshVisible: boolean,
        wireframe: boolean = false) {
            
        // important: width and height used in this class need to match dimensions of heightmap!
        var height = heightMapTextureAsArray.getImageHeight();
        var width = heightMapTextureAsArray.getImageWidth();

        this.physicsMaterial = physicsMaterial;
        
        this.generatedMesh = new THREE.Mesh(
            new THREE.PlaneGeometry( height, width, 100, 100),
            meshMaterial
        );

        let grid = new THREE.GridHelper( height, 10, 0xffffff, 0xffffff );
        grid.material.opacity = 1;
        grid.material.transparent = false;
        scene.add( grid );
              
        // physics object and mesh generated directly from physics object
        var dataArray2D = heightMapTextureAsArray.getArray();
        this.generateCannonHeightField(world, height, width, displacementHeightFactor, dataArray2D);        
        if(isCannonMeshVisible)
            this.generateThreeMeshFromCannonHeightField(scene, height, width, meshMaterial);

        // mesh generated by displacement map, using vertex and fragment shaders
        if(isTexturedMeshVisible) {
            const planeSize = width * 2;
            var material = this.generateMaterial(planeSize, heightMapTextureAsArray.getAssetName(), displacementHeightFactor, wireframe);
            this.generateSplattedMeshFromDisplacementPlane(scene, height, width, displacementHeightFactor, material);
        }        
    }
    
    getPhysicsMaterial(): CANNON.Material {
        
        if(this.physicsMaterial != null)
            return this.physicsMaterial;
        else
            throw new Error("No physics material set!")
    }

    getPosition() {
        return this.generatedMesh?.position;
    }

    update() {
        if(this.body != null) {
            this.generatedMesh.position.copy(Utility.CannonVec3ToThreeVec3(this.body.position));
            this.generatedMesh.quaternion.copy(Utility.CannonQuaternionToThreeQuaternion(this.body.quaternion));
            this.body.updateAABB();
        }        
    }

    generateCannonHeightField(world: CANNON.World, sizeX: number, sizeZ: number, displacementHeightFactor: number, dataArray2D: number[][] = []) {           
        // generate physics object
        var height = displacementHeightFactor;        
        var matrix: number[][] = [];

        if(dataArray2D.length > 0) {
          matrix = dataArray2D;
          for (let i = 0; i < sizeX; i++) {
            for (let j = 0; j < sizeZ; j++) {
              matrix[i][j] *= 10 / displacementHeightFactor;              
              matrix[i][j] += 1;
            }
          }
        }
        else {
          // default is to generate hills
          for (let i = 0; i < sizeX; i++) {
            
            matrix.push([]);
            for (let j = 0; j < sizeZ; j++) {
              if (i === 0 || i === sizeX - 1 || j === 0 || j === sizeZ - 1) {
                matrix[i].push(height);
                continue;
              }

              const height2 = Math.cos((i / sizeX) * Math.PI * 5) * Math.cos((j / sizeZ) * Math.PI * 5) * 2 + 2;
              matrix[i].push(height2);
            }
          }
        }

        const groundMaterial = new CANNON.Material('ground');
        this.heightfieldShape = new CANNON.Heightfield(matrix, {
          elementSize: 1, //100 / sizeX,
        });

        const heightfieldBody = new CANNON.Body({ mass: 0, material: groundMaterial });
        heightfieldBody.addShape(this.heightfieldShape);

        heightfieldBody.position.set(
          // -((sizeX - 1) * heightfieldShape.elementSize) / 2,
          -(sizeX * this.heightfieldShape.elementSize) / 2,
          -1,
          // ((sizeZ - 1) * heightfieldShape.elementSize) / 2
          (sizeZ * this.heightfieldShape.elementSize) / 2
        );
        heightfieldBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
        
        world.addBody(heightfieldBody);
        this.body = heightfieldBody;
    }    

    generateThreeMeshFromCannonHeightField(scene: THREE.Scene, sizeX: number, sizeZ: number, material: THREE.Material) {
        // generate THREE mesh: https://sbcode.net/threejs/physics-cannonDebugrenderer/
        
        let points: THREE.Vector3[] = [];
        var tempGeometry = new THREE.BufferGeometry();

        var tmpVec0: CANNON.Vec3 = new CANNON.Vec3()
        var tmpVec1: CANNON.Vec3 = new CANNON.Vec3()
        var tmpVec2: CANNON.Vec3 = new CANNON.Vec3()

        var shape = this.heightfieldShape;
        var v0 = tmpVec0;
        var v1 = tmpVec1;
        var v2 = tmpVec2;
        for (let xi = 0; xi < (shape as CANNON.Heightfield).data.length - 1; xi++) {
          for (let yi = 0; yi < (shape as CANNON.Heightfield).data[xi].length - 1; yi++) {
            for (let k = 0; k < 2; k++) {
              
              (shape as CANNON.Heightfield).getConvexTrianglePillar(xi, yi, k === 0);
              
              v0.copy((shape as CANNON.Heightfield).pillarConvex.vertices[0]);
              v1.copy((shape as CANNON.Heightfield).pillarConvex.vertices[1]);
              v2.copy((shape as CANNON.Heightfield).pillarConvex.vertices[2]);
              
              v0.vadd((shape as CANNON.Heightfield).pillarOffset, v0);
              v1.vadd((shape as CANNON.Heightfield).pillarOffset, v1);
              v2.vadd((shape as CANNON.Heightfield).pillarOffset, v2);

              points.push(new THREE.Vector3(v0.x, v0.y, v0.z), new THREE.Vector3(v1.x, v1.y, v1.z), new THREE.Vector3(v2.x, v2.y, v2.z));
              //const i = geometry.vertices.length - 3
              //geometry.faces.push(new THREE.Face3(i, i + 1, i + 2))
            }
          }
        }
        tempGeometry.setFromPoints(points);
        //tempGeometry.computeFaceNormals();
        tempGeometry.computeVertexNormals();
        //tempGeometry.computeTangents();
        tempGeometry.computeBoundingBox();

        var mesh = new THREE.Mesh(tempGeometry, material);
        mesh.scale.set(1, 1, 1);
        mesh.position.set(
            // -((sizeX - 1) * heightfieldShape.elementSize) / 2,
            -(sizeX * this.heightfieldShape.elementSize) / 2,
            -1,
            // ((sizeZ - 1) * heightfieldShape.elementSize) / 2
            (sizeZ * this.heightfieldShape.elementSize) / 2
        );
        mesh.rotation.x = - Math.PI / 2;
        mesh.castShadow = false;
        mesh.receiveShadow = true;  
        
        this.generatedMesh = mesh;
        scene.add(this.generatedMesh);
    }

    generateMaterial(planeSize: number, asset: string, displacementHeightFactor: number, wireframe: boolean ): THREE.Material {

      const displacementMap = new THREE.TextureLoader().load(asset);

        if(wireframe)
          return new THREE.MeshStandardMaterial({color: 0x007700,wireframe: true, displacementMap: displacementMap, displacementScale: displacementHeightFactor });
        
        const repeats = planeSize / 2;
        const loader = new THREE.TextureLoader();

        const texture1 = this.loadAndConfigureTexture(loader, 'assets/Sand 4.jpg', repeats);                
        const texture2 = this.loadAndConfigureTexture(loader, 'assets/tileable_grass_00.png', repeats);        
        const texture3 = this.loadAndConfigureTexture(loader, 'assets/tileable_grass_01.png', repeats);        
        const texture4 = this.loadAndConfigureTexture(loader, 'assets/stone 3.png', repeats);
        const texture5 = this.loadAndConfigureTexture(loader, 'assets/snow.png', repeats);

        return new THREE.ShaderMaterial({
            uniforms: {
                level1Texture: { value: texture1},
                level2Texture: { value: texture2 },
                level3Texture: { value: texture3 },
                level4Texture: { value: texture4 },
                level5Texture: { value: texture5 },
                displacementMap: { value: displacementMap },
                displacementScale: {value: displacementHeightFactor},
                lightMap: { value: displacementMap },
                wireFrame: { value: true }
            },
            vertexShader: this.vertexShader3(),
            fragmentShader: this.fragmentShader3(),
        });
    }
    generateSplattedMeshFromDisplacementPlane(scene: THREE.Scene, height: number, width: number, displacementHeightFactor: number, material: THREE.Material) {

        this.displacementMesh = new THREE.Mesh(
            new THREE.PlaneGeometry( height, width, 100, 100),
            material
        );
        
        this.displacementMesh.scale.set(1, 1, displacementHeightFactor);

        
        this.displacementMesh.rotation.x = -Math.PI / 2;
        this.displacementMesh.rotation.z = Math.PI / 2;

        this.displacementMesh.position.set(0, 0.5, 0.6);
        //this.displacementMesh.position.set(0, 0, 0);
        
        /*
        this.mesh.position.setX(height / 2);
        this.mesh.position.setY(0);
        this.mesh.position.setZ(-width);
        */

        this.displacementMesh.castShadow = false;
        this.displacementMesh.receiveShadow = true;  

        const uv = this.displacementMesh.geometry.getAttribute('uv');
        const position = this.displacementMesh.geometry.getAttribute('position');

        console.log(position.count); // 4 ( the are points or vertices )
        console.log(position.array.length); // 12 ( x, y, and z for each point )
        // THE UV ATTRIBUTE
        console.log(uv.count); // 4 ( the are points or vertices )
        console.log(uv.array.length); // 8 ( there is a u and v value for each point )

        scene.add(this.displacementMesh)
                
        let grid = new THREE.GridHelper( height, 10, 0xffffff, 0xffffff );
        grid.material.opacity = 1;
        grid.material.transparent = false;
        scene.add( grid );
    }

    loadAndConfigureTexture(loader: THREE.TextureLoader, asset: string, repeats: number): THREE.Texture
    {
        const texture = loader.load(asset);                
        texture.wrapS = THREE.RepeatWrapping;
        texture.wrapT = THREE.RepeatWrapping;
        texture.magFilter = THREE.NearestFilter;
        texture.colorSpace = THREE.SRGBColorSpace;
        texture.repeat.set(repeats, repeats);

        return texture;
    }

    vertexShader3() {
        return `
        uniform sampler2D displacementMap;
        uniform float displacementScale;

        varying float vAmount;
        varying vec2 vUV;

        void main() 
        { 
            vUV = uv;
            vec4 displacementData = texture2D( displacementMap, uv );
            
            vAmount = displacementData.r; // assuming map is grayscale it doesn't matter if you use r, g, or b.
            
            // move the position along the normal
            vec3 newPosition = position + normal * displacementScale * vAmount;
            
            gl_Position = projectionMatrix * modelViewMatrix * vec4( newPosition, 1.0 );
        }
        `
    }

    fragmentShader3() {
        return `
        uniform sampler2D level1Texture;
        uniform sampler2D level2Texture;
        uniform sampler2D level3Texture;
        uniform sampler2D level4Texture;
        uniform sampler2D level5Texture;

        varying vec2 vUV;

        varying float vAmount;

        void main() 
        {
            vec4 water = (smoothstep(-1.00, 0.25, vAmount) - smoothstep(0.24, 0.26, vAmount)) * texture2D( level1Texture, vUV * 10.0 );
            vec4 sandy = (smoothstep(0.24, 0.27, vAmount) - smoothstep(0.28, 0.31, vAmount)) * texture2D( level2Texture, vUV * 10.0 );
            vec4 grass = (smoothstep(0.28, 0.32, vAmount) - smoothstep(0.35, 0.40, vAmount)) * texture2D( level3Texture, vUV * 20.0 );
            vec4 rocky = (smoothstep(0.30, 0.50, vAmount) - smoothstep(0.40, 0.70, vAmount)) * texture2D( level4Texture, vUV * 20.0 );
            vec4 snowy = (smoothstep(0.50, 0.65, vAmount))                                   * texture2D( level5Texture, vUV * 10.0 );
            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0) + water + sandy + grass + rocky + snowy; //, 1.0);
        }  
        `
    }
}